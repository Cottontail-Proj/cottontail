
/**
 * @file GenericTree.h
 * University of Illinois CS 400, MOOC 2, Week 3: Generic Tree
 *
 * @author Eric Huber
 *
**/

// We use the pragma once directive to ensure that this header won't
// be included multiple times per compilation unit by mistake.
#pragma once

#include <stdexcept> // for std::runtime_error
#include <stack> // for std::stack
#include <queue> // for std::queue
#include <vector> // for std::vector
#include <iostream> // for std::cerr, std::cout
#include <ostream> // for std::ostream

// -------------------------------------------------------------------
// GenericTree<T> class
// -------------------------------------------------------------------
// A generic, N-ary tree. Each node can hold an element of data as specified
// by the template argument, and a node can have zero or more children that
// all are roots of subtrees themselves. In general terms, we'll think of the
// vector of children for each node being arranged from left to right, with
// the leftmost child listed first. However, our print functionality for the
// text terminal will output trees in a vertical orientation, where the
// "leftmost" branches are output first, at the top.
// 
// You do not need to edit this file for the assignment. You only need
// to make edits in GenericTreeExercises.h. However, you are welcome
// to study this file for insight about how the class works, as well as
// tips on how to approach the exercises in the assignment.

// for json
#include <nlohmann/json.hpp>
using json = nlohmann::json;



template <typename T>
class GenericTree {
public:

  // This toggles whether to output extra debugging messages.
  // We'll set it to false by default.
  bool showDebugMessages;

  // An internal class type for tree nodes.
  class TreeNode {
  public:
    // Pointer to the node's parent (nullptr if there is no parent)
    TreeNode* parentPtr;

    bool taken = 0;
    int branch_id = 0;
    int call_stack_size = 0;
    int branch_type = 0; // 0 is if-else (an others only have true/false); 1 is switch
    int visit_cnt = 0;
    unsigned long long node_id = 0;
    
    // List of pointers to this node's children, if any.
    // This will automatically be constructed empty by default.
    // This could be implemented with something other than std::vector,
    // such as std::list or std::set. There are various advantages to
    // different strategies, depending on how you design the tree class
    // functions.
    std::vector< TreeNode* > childrenPtrs;
    
    // The actual node data. It's an actual copy of the node's data,
    // not just a pointer or reference. This is slightly different
    // from the binary tree structure presented in lecture.
    T data;

    // Add a rightmost child to this node storing a copy of the provided data.
    // Returns a pointer to the new child node.
    TreeNode* addChild(const T& childData, bool takenFlag = false, int branchType = 0, int branchId = -1, int callStackSize = 0, int visitCnt=0);

    // Default constructor: Indicate that there is no parent.
    TreeNode() : parentPtr(nullptr) {}

    // Constructor based on data argument:
    // Specifies no parent, but does copy in the data member by value.
    TreeNode(const T& dataArg) : parentPtr(nullptr), data(dataArg) {}

    // There is a special syntax for disabling certain constructors entirely.
    // This inhibits default versions from being generated by the compiler.
    // We'll do this here for simplicity, and to prevent you from attempting
    // the assignment in a way other than intended.

    // If you wanted to implement copying, consider this: Would you want
    // to perform a shallow copy or a deep copy of your data structure by
    // default? What would your users expect to happen?

    // Copy constructor: We will disable it.
    TreeNode(const TreeNode& other) = delete;

    // Copy assignment operator: We will disable it.
    TreeNode& operator=(const TreeNode& other) = delete;

    // Destructor: Although we don't seem to write anything here,
    // the members of the node class will have their own destructors
    // automatically called afterward.
    ~TreeNode() {}

  };

public:
  // The tree has this pointer to its root node as an entry point,
  // which should be set to nullptr when the tree is empty.
  TreeNode* rootNodePtr;

  int getDepth() const {
        return calculateDepth(rootNodePtr);
    }

public:

  // A warning about best practices for designing a class interface:
  // The next few functions below are unsafe because they use raw
  // pointers to the class internal structure as public input or output.
  // Ideally, you could build an interface for your class that doesn't
  // expose the underlying pointers of the class publicly, because users
  // could easily misuse your class that way.

  // Create the root node (which must not already exist).
  // The rootData parameter gives the original data that should be copied
  // into the root node. Returns the root node pointer.
  TreeNode* createRoot(const T& rootData);

  // Get a copy of the raw pointer to the root node of this class instance.
  TreeNode* getRootPtr() {
    return rootNodePtr;
  }

  // Deallocate the entire subtree beginning with the intended node;
  // this includes the specified node as well as all of its decendents.
  // If the node pointer is null, nothing will be done.
  // The node must be in the same tree that's calling the function, or else
  //   an exception will be thrown.
  // If it's the root of the whole tree, rootNodePtr will be reset to nullptr.
  void deleteSubtree(TreeNode* targetRoot);

  // If any null pointers have been added to the tree as children,
  // or if any have been left behind after deleting subtrees, then
  // this function compresses the space usage in the vector of children
  // pointers so those null pointers are removed.
  // (This wouldn't be necessary to do if we used a linked list for the
  //  children pointers instead. But this is pretty easy to use.)
  void compress();

  // Default constructor: Indicate that there is no root (empty tree).
  GenericTree() : showDebugMessages(false), rootNodePtr(nullptr) {}

  // Parameter constructor: Creates an empty tree, then adds a root node
  // with the provided data.
  GenericTree(const T& rootData) : GenericTree() {
    createRoot(rootData);
  }

  // Copy constructor: We will disable it.
  GenericTree(const GenericTree& other) = delete;

  // Copy assignment operator: We will disable it.
  GenericTree& operator=(const GenericTree& other) = delete;

  void clear() {
    // Use our special function to deallocate the entire tree
    deleteSubtree(rootNodePtr);

    // In this case, since we targeted rootNodePtr (for the whole tree),
    // the deleteSubtree function resets rootNodePtr to nullptr for us.
    // If it had not, this would be a good place to ensure that the
    // rootNodePtr does indeed get reset, for safety.

    if (rootNodePtr) {
      throw std::runtime_error("clear() detected that deleteSubtree() had not reset rootNodePtr");
    }
  }

  int countTreeNodes() const {
    if (!rootNodePtr) return 0; // If the tree is empty, return 0

    int count = 0;

    // Use a queue for breadth-first traversal to count all nodes
    std::queue<TreeNode*> nodesToVisit;
    nodesToVisit.push(rootNodePtr);

    while (!nodesToVisit.empty()) {
        auto* currentNode = nodesToVisit.front();
        nodesToVisit.pop();

        count++; // Increment the count for the current node

        // Add all child nodes to the queue
        for (auto* child : currentNode->childrenPtrs) {
            if (child) {
                nodesToVisit.push(child);
            }
        }
    }

    return count;
}



  TreeNode* findNode(const T& targetData, int branch_id, int call_stack_size) const {
  //TreeNode* findNode(const T& targetData, int size) const {
        if (!rootNodePtr) return nullptr;

        std::queue<TreeNode*> nodesToExplore;
        nodesToExplore.push(rootNodePtr);

        while (!nodesToExplore.empty()) {
            TreeNode* currentNode = nodesToExplore.front();
            nodesToExplore.pop();

            //if (currentNode->data == targetData) {
            if (currentNode->data == targetData && currentNode->call_stack_size == call_stack_size 
                    && currentNode->branch_id == branch_id /*&& currentNode->branch_type == branch_type*/) {
                /*
                std::cout << "Node Found: name = " << currentNode->data
                      << ", branchType = " << currentNode->branch_type
                      << ", branchId = " << currentNode->branch_id
                      << ", callStackSize = " << currentNode->call_stack_size << "\n";
                      */
                return currentNode;
            }

            for (auto* child : currentNode->childrenPtrs) {
                if (child) nodesToExplore.push(child);
            }
        }
      
        std::cout << "\033[1;31m"  // Start red color (bold text)
          << " Not Found!!! "
          << targetData
          << " branch_id = " << branch_id
          << " callStackSize = " << call_stack_size
          << "\033[0m"  // Reset color to default
          << "\n";
         //exit(1);
        return nullptr;
    }

bool addChildToNode(const T& parentData, const T& childData, int p_branch_id, int p_call_stack_size, int branchType = 0, bool takenFlag = false, 
          int branchId = -1, int callStackSize = 0, int visitCnt=0) const{
  //std:cout << "callStackSize = " << callStackSize << "\n";
  //TreeNode* parentNode = findNode(parentData, callStackSize);
  TreeNode* parentNode = nullptr;
  //if (parentData.find("root") != std::string::npos) {
  //      parentNode = findNode(parentData, 0); // Use callStackSize = 0 for root
   // } else {
        //parentNode = findNode(parentData, callStackSize - 1); // Use provided callStackSize
  parentNode = findNode(parentData, p_branch_id, p_call_stack_size); // Use provided callStackSize
   // }

  if (parentNode) {
      parentNode->addChild(childData, takenFlag, branchType, branchId, callStackSize, visitCnt);
      return true;
  } else {
    return false;
  }
}

  // Destructor
  ~GenericTree() {
    clear();
  }

  // Print the tree to the output stream (for example, std::cout) in a vertical text format
  std::ostream& Print(std::ostream& os) const;
  void printNodeAsJson(std::ostream& os, const typename GenericTree<T>::TreeNode* node, int depth) const;
  void saveToJsonFile(const std::string& filename) const;
  //void loadFromJsonString(const std::string& jsonString);
  //void loadChildrenFromJson(const typename GenericTree<T>::TreeNode* parent, const json& childrenJson);
  void loadFromJsonFile(const std::string& filename);
  typename GenericTree<T>::TreeNode* loadNodeFromJson(const json& nodeJson);
  int calculateDepth(const TreeNode* node) const;
  typename GenericTree<T>::TreeNode* nodeExists(const T& name, int callStackSize) const;
  typename GenericTree<T>::TreeNode* findNodeByNameAndBranchID(const T& name, int branch_type, int branch_id, int call_stack_size) const;
  //bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node);
};

// Operator overload that allows stream output syntax
template <typename T>
std::ostream& operator<<(std::ostream& os, const GenericTree<T>& tree) {
  return tree.Print(os);
}

// =======================================================================
//   Implementation section
// =======================================================================

// Notes about checking whether pointers are null:

// When checking whether a pointer is null or not, several pieces of syntax
// have the same effect. If you have a pointer called ptr, both of these
// expressions check if the pointer is null:
//   if (nullptr == ptr)
//   if (!ptr)
// Both of these expressions check if the pointer is NOT null, meaning it
// has any nonzero value:
//   if (nullptr != ptr)
//   if (ptr)

// Notes about implementing templated member functions:

// Since this is a templated class, there are special considerations
// about where to write the implementation of the member functions.
// The compiler uses templates to generate code at compile time, and so it
// needs to have a complete definition of the template in each compilation
// unit. (Those are the separate .cpp files that are compiled into .o files
// before being linked together into an executable). One way to ensure this
// is to implement the templated functions right here in the header file
// itself, instead of using a cpp file for the class implementation.

// There are other ways to deal with this issue. We could write a separate
// header file with the implementation and include it here with some extra
// preprocessor directives. That would at least keep the implementation in
// a separate file for easy editing, but it wouldn't speed up recompilation
// at all. Another way to deal with it is to place the implementation in
// a cpp file, but then we must explicitly declare ahead of time in that cpp
// file all of the versions of our template that may be used. That makes it
// harder for other people to reuse the library without editing the library
// files.

// Another issue is that our inner TreeNode class type is dependent
// on a specific instance of the GenericTree<T> class template. Within these
// function definitions, we can simply refer to "TreeNode" and the
// compiler will know what we mean. But to use TreeNode as a return
// type at global scope, we have to certify that GenericTree<T>::TreeNode
// is a type by writing "typename" before it as well.

template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::createRoot(const T& rootData) {
  
  // If the rootNodePtr member variable already has a nonzero value assigned,
  // then the root node already exists, and it's an error to try to recreate it.
  if (nullptr != rootNodePtr) {
    // We don't always need to import <string> just to reuse a short error message.
    // We can store short strings as constant arrays of char type at compile time.
    // (A constexpr is similar to const, but must be entirely evaluated at compile time.)
    constexpr char ERROR_MESSAGE[] = "Tried to createRoot when root already exists";
    // Display the error message to the standard error stream.
    std::cerr << ERROR_MESSAGE << std::endl;
    // Throw an exception containing the error message.
    // We won't catch the exception, so this terminates the program.
    throw std::runtime_error(ERROR_MESSAGE);
  }

  // Note that since TreeNode is a member type defined in the internal
  // namespace of our templated GenericTree<T> class, here we implicitly have
  // the correct version of TreeNode containing a "T data" member.
  // When we allocate a new node here, we don't need to write a template
  // argument on the constructor like "TreeNode<T>".

  // Construct the root node on the heap with the given data
  rootNodePtr = new TreeNode(rootData);

  // Return a copy of the root node pointer.
  return rootNodePtr;
}

/*
template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::TreeNode::addChild(const T& childData, bool takenFlag, int branchType, int branchId, int callStackSize) {


  
  // We prepare a new child node with the given data.
  TreeNode* newChildPtr = new TreeNode(childData);

  // The "this" pointer in C++ always points to the current instance of the
  //  class for which we are defining a function body.
  // Here, "this" is a pointer to the current TreeNode.

  // Assign this current node as the new child's parent pointer.
  newChildPtr->parentPtr = this;
  
  // This node (the parent) already has a data structure to keep track
  // of its children pointers. We add the new child to the list.
  childrenPtrs.push_back(newChildPtr);

  // THX
  newChildPtr->taken = takenFlag;
  newChildPtr->branch_id = branchId;
  newChildPtr->call_stack_size = callStackSize;
  newChildPtr->branch_type = branchType;

  // Return a copy of the pointer to the new child.
  return newChildPtr;
}
*/

template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::TreeNode::addChild(const T& childData, bool takenFlag, int branchType,
        int branchId, int callStackSize, int visitCount) {


  
  // We prepare a new child node with the given data.
  TreeNode* newChildPtr = new TreeNode(childData);

  // The "this" pointer in C++ always points to the current instance of the
  //  class for which we are defining a function body.
  // Here, "this" is a pointer to the current TreeNode.

  // Assign this current node as the new child's parent pointer.
  newChildPtr->parentPtr = this;
  
  // This node (the parent) already has a data structure to keep track
  // of its children pointers. We add the new child to the list.
  childrenPtrs.push_back(newChildPtr);

  // THX
  newChildPtr->taken = takenFlag;
  newChildPtr->branch_id = branchId;
  newChildPtr->call_stack_size = callStackSize;
  newChildPtr->branch_type = branchType;
  newChildPtr->visit_cnt = visitCount;
  // Return a copy of the pointer to the new child.
  return newChildPtr;
}


template <typename T>
void GenericTree<T>::deleteSubtree(TreeNode* targetRoot) {

  // Deleting a subtree requires deallocating the memory used by the nodes,
  // but since the pointers are stored in the tree itself, we need to
  // traverse the subtree to identify those pointers. We have to be careful
  // about the order in which we do this so that we can reach all the nodes
  // that need to be deleted.

  // We could have implemented this function recursively, since every node
  // in the tree is like the root of another subtree. When traversing the
  // tree recursively, each call to the recursive function has to wait for
  // the recursive calls it makes to return, creating a "call stack". In
  // essence, the recursive calls act like an implicit data structure
  // themselves, based on the order in which they are called and return.
  // That is a very elegant way to write this in some languages, and this
  // course's lectures on binary search trees show how you can do that.
  
  // However, recursion in C++ can also cause problems if too many layers
  // of recursion happen in succession before returning, because of the
  // finite amount of stack memory allocated for each C++ program. There
  // are special design considerations to think about when you want to
  // ensure that recursion will be optimized by the compiler.
  
  // Here is a way to do it iteratively, using loops instead of recursion.
  // We need to use an explicit data structure (such as a stack) to
  // keep track of nodes that still need to be traversed, since we won't
  // rely on the call stack to do that implicitly.

  // If the targeted subtree root doesn't exist, then there is nothing to do.
  if (nullptr == targetRoot) {
    return;
  }

  // Check that the specified node to delete is in the same tree as this
  // class instance that's calling the function.
  {
    TreeNode* walkBack = targetRoot;
    while (walkBack->parentPtr) {
      // Walk back from the targeted node to its ultimate parent, the root.
      // (The root has no parent, so the walk ends there.)
      walkBack = walkBack->parentPtr;
    }
    // The ultimate root found must be this tree's root. Otherwise we're in
    // a different tree.
    if (walkBack != rootNodePtr) {
      throw std::runtime_error("Tried to delete a node from a different tree");
    }
  }

  // We'll take note whether this is the root of the entire tree.
  bool targetingWholeTreeRoot = (rootNodePtr == targetRoot);

  // If the subtree root node has a parent, then the parent should no longer
  // list it as a child. (Otherwise, targetRoot is actually the root of the
  // whole tree, so it has no parent, and we can skip this section.)
  if (targetRoot->parentPtr) {

    // A flag for error checking: We need to find the target node
    // listed as a child of its parent. We will keep track as we search.
    bool targetWasFound = false;
    
    // Loop through the parent's listed children using a reference variable
    // in a range-based for loop. (Yes, currentChildPtr is a pointer, but
    // we're accesssing each pointer directly by reference this way, so we
    // can change the original pointers stored in targetRoot->parentPtr->childrenPtrs
    // that we are iterating over, instead of acting on temporary copies.)
    // If the child is found under its parent as expected, overwrite it
    // in-place with nullptr.
    for (auto& currentChildPtr : targetRoot->parentPtr->childrenPtrs) {
      if (currentChildPtr == targetRoot) {
        // We found where the parent node is pointing to the target
        // node as its child. Replace that pointer with a null pointer.
        currentChildPtr = nullptr;
        // Flag that our search succeeded, for error checking.
        targetWasFound = true;
        // Stop looping early. The "break" statement exits the current "for"
        // loop and moves on to the next statement outside.
        break;
      }
    }

    // If the target node was not found, our tree is malformed somehow.
    if (!targetWasFound) {
      // If this flag is still false, we have some kind of bug.
      // The target should have been listed as a child of its parent.
      constexpr char ERROR_MESSAGE[] = "Target node to delete was not listed as a child of its parent";
      std::cerr << ERROR_MESSAGE << std::endl;
      throw std::runtime_error(ERROR_MESSAGE);
    }
  }

  // Now, we need to make sure all the descendents get deleted. We have to
  // think ahead about how to do this. Is there a specific order we must use
  // to delete items? For some class designs, if we delete elements in the
  // wrong order, we will break the internal structure of our class and
  // lose our record of where the disconnected pieces are. For example, if
  // we deleted our root node before recording where its children were, the
  // rest of the tree would remain in memory, but without any pointers
  // pointing to it. There would be no way to access the data or free the
  // memory until the entire program ends. That's a memory leak.

  // On the other hand, even if we record where the root node's children are
  // before deleting the root node, we still might not want to immediately
  // delete the children. If the delete operation triggers a subtree removal
  // rooted at each child, as we have our destructor set up currently, this
  // would end up being recursive. This goes back to the question of whether
  // we are okay with using a recursive algorithm to traverse our entire tree.
  // In this function, we're trying to avoid that and use iteration instead.

  // For our current data structure, let's try this method:
  // First, let's traverse the entire tree without deleting anything,
  // while writing down all the pointers that we find in a certain order.
  // For the ordering, we want to be able to delete the nodes from the bottom
  // of the tree upwards, so that children are deleted before their parents.
  // For example, a post-order traversal of the nodes would accomplish this.

  // We can do this iteratively using two stack data structures. We'll use
  // one stack to record which nodes to "explore" next as we descend the tree,
  // one branch at a time; we will actually descend the rightmost branches
  // first, because if a given node's children are pushed onto the explore
  // stack from left to right, the rightmost child will be popped and explored
  // next. Meanwhile, each time we "explore" a node, we'll push it onto
  // a stack of nodes to be deleted at the very end. The leftmost branch's
  // leftmost child will be explored last and deleted first. This way, the
  // delete operations happen in post order from left to right.

  // Our stack of nodes that still need to be explored (and then deleted)
  std::stack<TreeNode*> nodesToExplore;

  // We also need a stack for the pointers that need to be deleted:
  std::stack<TreeNode*> nodesToDelete;

  // To begin with, we'll record that the target node, which is the root of
  // the subtree, needs to be explored:
  nodesToExplore.push(targetRoot);

  // Keep looping as long as there are nodes left to explore and delete.
  while (!nodesToExplore.empty()) {

    // Get a copy of the top pointer on the explore stack.
    TreeNode* curNode = nodesToExplore.top();

    // Now that we've retrieved the top pointer, we can pop it from the explore stack.
    nodesToExplore.pop();

    if (showDebugMessages) {
      std::cerr << "Exploring node: ";
      if (curNode) {
        // if curNode isn't null, we can show what it contains
        std::cerr << curNode->data << std::endl;
      }
      else {
        std::cerr << "[null]" << std::endl;
      }
    }

    // If nullptr...
    if (!curNode) {
      // The "continue" statement jumps to the top of the next iteration
      // of the while loop.
      continue; 
    }

    // Record that we need to delete this node later, by pushing it onto the delete stack.
    nodesToDelete.push(curNode);

    // Loop through the current node's children pointers from first to last,
    // which we interpret as left to right
    for (auto childPtr : curNode->childrenPtrs) {
      // Push a copy of the child pointer onto the stack of children to explore
      nodesToExplore.push(childPtr);
    }

  } // End of explore loop.

  // We're done exploring all the nodes in the tree now, so now we need
  // to delete the nodes one at a time from the delete stack.
  while (!nodesToDelete.empty()) {
    
    // Get a copy of the top pointer on the delete stack.
    TreeNode* curNode = nodesToDelete.top();

    // Now that we've retrieved the top pointer, we can pop it from the stack.
    nodesToDelete.pop();

    if (showDebugMessages) {
      std::cerr << "Deleting node: ";
      if (curNode) {
        // if curNode isn't null, we can show what it contains
        std::cerr << curNode->data << std::endl;
      }
      else {
        std::cerr << "[null]" << std::endl;
      }
    }

    // Delete the current node pointer.
    delete curNode;

    // As a good practice, we'll try to set pointers to nullptr after we
    // delete them. This is somewhat unnecessary here, because this local
    // variable is about to go out of scope when the while loop iterates,
    // but it can help you catch mistakes in many other situations.
    curNode = nullptr;

    // You want to avoid deleting the same memory address more than once
    // by mistake, or dereferencing an address that is no longer allocated.
    // After setting a pointer to nullptr:
    // If you "delete" a nullptr, it's safe; nothing will happen.
    // If you dereference a nullptr, the program will crash, and
    // you'll quickly discover the source of the problem.
  }

  // If we deleted the root node of this class instance,
  //  then reset the root pointer.
  if (targetingWholeTreeRoot) {
    rootNodePtr = nullptr;
  }

  return;
}

template <typename T>
void GenericTree<T>::compress() {

  // We'll use an iterative approach to traversing the tree here.
  // In this function, we don't ever want to push null pointers onto the
  // exploration queue. Some exploration techniques do push null pointers, as
  // long as they have a robust base case to handle "exploring" a null pointer,
  // but this time, whenever we explore a new node, we're going to make a
  // compressed copy of its vector of children pointers that has all the null
  // pointers removed.

  // If there's no root, return.
  if (!rootNodePtr) return;

  // Queue of node pointers that we still need to explore (constructed empty)
  std::queue<TreeNode*> nodesToExplore;

  // Begin by pushing our root pointer onto the queue
  nodesToExplore.push(rootNodePtr);

  // Loop while there are still nodes to explore
  while (!nodesToExplore.empty()) {

    // Make a copy of the front pointer on the queue, then pop it to decrease the queue
    TreeNode* frontNode = nodesToExplore.front();
    nodesToExplore.pop();

    if (!frontNode) {
      // The front node pointer should not be null, because we're designing this
      // function so that no null pointers should ever get pushed onto the exploration queue.
      throw std::runtime_error("Error: Compression exploration queued a null pointer");
    }

    // If the node exists, it may have children pointers. Let's make
    // an empty vector of children node pointers and get ready to make
    // a compressed copy of this node's children pointers.
    std::vector<TreeNode*> compressedChildrenPtrs;
    // Now loop through the currently recorded children pointers...
    for (auto childPtr : frontNode->childrenPtrs) {
      if (childPtr) {
        // If this child pointer is not null, then push it onto the back
        // of our new, compressed pointers vector.
        compressedChildrenPtrs.push_back(childPtr);
        // Also put this child pointer onto the end of the exploration queue.
        nodesToExplore.push(childPtr);
      }
    }

    // Here's a little trick: the std::vector::swap() function lets us replace
    // the node's actual children pointer vector with the new one, even
    // though the compressed one is a local variable here. The standard
    // template library swaps the internals of the two structures so that
    // the old one expires here at local scope, while the new one lives on
    // with our node.
    frontNode->childrenPtrs.swap(compressedChildrenPtrs);
  }

}

// THX: newly added

template <typename T>
std::ostream& GenericTree<T>::Print(std::ostream& os) const {
    if (rootNodePtr) {
        os << "{\n  \"root\": ";
        printNodeAsJson(os, rootNodePtr, 1);
        os << "\n}"; // Close the root object
    } else {
        os << "{}"; // Empty JSON object for an empty tree
    }
    return os;
}

/*
d (data): file name + function name + loc
y (taken): 1 or 0
s (call_stack_size)
b (br) : branch label 
  * for non-switch: if - 0; else - 1;
c (children)

*/

template <typename T>
void GenericTree<T>::printNodeAsJson(std::ostream& os, const typename GenericTree<T>::TreeNode* node, int depth) const {
    if (!node) return;

    std::string indent(depth * 2, ' '); // Indentation for readability

    os << "{\n" << indent << " \"loc\":\"" << node->data << "\",";
    os << indent << "\"tp\": " << node->branch_type <<",";
    os << indent << "\"tk\": " << node->taken <<",";
    os << indent << "\"cs\": " << node->call_stack_size <<",";
    os << indent << "\"vc\": " << node->visit_cnt <<",";
    os << indent << "\"br\": " << node->branch_id;

    if (!node->childrenPtrs.empty()) {
        os << ",\n" << indent << "  \"ch\": [\n";
        for (size_t i = 0; i < node->childrenPtrs.size(); ++i) {
            os << indent << "    ";
            printNodeAsJson(os, node->childrenPtrs[i], depth + 2);
            if (i < node->childrenPtrs.size() - 1) {
                os << ",\n"; // Add comma between children
            }
        }
        os << "\n" << indent << "  ]";
    } else { // output nothing
        ; // os << ",\n" << indent << "  \"ch\": []"; // Empty children array for a leaf node
    }

    os << "\n" << indent << "}";
}

template <typename T>
void GenericTree<T>::saveToJsonFile(const std::string& filename) const {
    std::ofstream file(filename);
    if (!file) {
        throw std::runtime_error("Error opening file for writing: " + filename);
    }

    Print(file);  // Write JSON directly to file
    file << "\n";
    file.close();
}

template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::loadNodeFromJson(const json& nodeJson) {
    // Retrieve the node data and create the node
    T data = nodeJson["loc"].get<T>();
    TreeNode* node = new TreeNode(data);
    node->taken = nodeJson.value("tk", 0); // Default `taken` value to 0 if not present
    node->branch_id = nodeJson.value("br", 0); // Default `branch` value to 0 if not present
    node->call_stack_size = nodeJson.value("cs", 0); // Default `call_stack_size` value to 0 if not present
    node->branch_type = nodeJson.value("tp", 0); // Default `branch_type` value to 0 if not present
    node->visit_cnt = nodeJson.value("vc", 0); // Default `visit_cnt` value to 0 if not present

    // Recursively load children if present
    if (nodeJson.contains("ch")) {
        for (const auto& childJson : nodeJson["ch"]) {
            TreeNode* child = loadNodeFromJson(childJson);
            if (child) {
                child->parentPtr = node;
                node->childrenPtrs.push_back(child);
            }
        }
    }
    return node;
}

template <typename T>
void GenericTree<T>::loadFromJsonFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("Error opening JSON file: " + filename);
    }

   // Read and print file content
    std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    //std::cout << "File content before loading:\n" << fileContent << std::endl;

    // Parse JSON from the string content
    json j = json::parse(fileContent);
    
    file.close();

    // Clear existing tree if it exists
    clear();

    // Check if JSON has a root node and load it
    if (j.contains("root")) {
        rootNodePtr = loadNodeFromJson(j["root"]);
    } else {
        throw std::runtime_error("JSON does not contain a valid root node.");
    }
}

// Helper function to calculate the depth of a subtree
template <typename T>
int GenericTree<T>::calculateDepth(const TreeNode* node) const {
    if (node == nullptr) {
        return 0;  // Base case: An empty tree has a depth of 0
    }

    int maxDepth = 0;
    for (const TreeNode* child : node->childrenPtrs) {
        // Recursively calculate the depth of each child
        int childDepth = calculateDepth(child);
        maxDepth = std::max(maxDepth, childDepth);
    }

    // Depth of the current node is 1 plus the maximum depth of its children
    return 1 + maxDepth;
}

/*
template <typename T>
bool GenericTree<T>::nodeExists(const T& name, int call_stack_size) const {
    // If the tree is empty, the node cannot exist
    if (!rootNodePtr) return false;

    // Use a queue for breadth-first search
     std::queue<std::pair<TreeNode*, int>> nodesToVisit;
    nodesToVisit.push({rootNodePtr, 0}); // Start with the root at depth 0

    // Traverse the tree
    while (!nodesToVisit.empty()) {
        auto [currentNode, currentDepth] = nodesToVisit.front();
        nodesToVisit.pop();

        // Check if the current node matches the specified name
        if (currentNode->data == name && currentNode->call_stack_size == call_stack_size 
        ) {
            return true;
        }

        // Enqueue all children of the current node for further exploration
        for (TreeNode* child : currentNode->childrenPtrs) {
            if (child) {
                nodesToVisit.push({child, call_stack_size});
            }
        }
    }

    // If we exit the loop without finding the node, it doesn't exist
    return false;
}
*/
template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::nodeExists(const T& name, int call_stack_size) const {
    // If the tree is empty, the node cannot exist
    if (!rootNodePtr) return nullptr;

    // Use a queue for breadth-first search
    std::queue<TreeNode*> nodesToVisit;
    nodesToVisit.push(rootNodePtr); // Start with the root node

    // Traverse the tree
    while (!nodesToVisit.empty()) {
        TreeNode* currentNode = nodesToVisit.front();
        nodesToVisit.pop();

        // Check if the current node matches the specified name and call_stack_size
        if (currentNode->data == name && currentNode->call_stack_size == call_stack_size) {
            return currentNode; // Node found, return the pointer
        }

        // Enqueue all children of the current node for further exploration
        for (TreeNode* child : currentNode->childrenPtrs) {
            if (child) {
                nodesToVisit.push(child);
            }
        }
    }

    // If we exit the loop without finding the node, it doesn't exist
    return nullptr;
}


template <typename T>
typename GenericTree<T>::TreeNode* GenericTree<T>::findNodeByNameAndBranchID(const T& name, int branch_type,  int branch_id, int call_stack_size) const {
    if (!rootNodePtr) return nullptr; // If the tree is empty, return nullptr

    // Queue for breadth-first traversal to search the tree
    std::queue<TreeNode*> nodesToExplore;
    nodesToExplore.push(rootNodePtr);

    // Traverse the tree level-by-level
    while (!nodesToExplore.empty()) {
        TreeNode* currentNode = nodesToExplore.front();
        nodesToExplore.pop();

        // Check if this node matches the desired name and branch_id as well as call_stack_size
        if (currentNode->data == name && currentNode->branch_id == branch_id &&
        currentNode->branch_type == branch_type && currentNode->call_stack_size == call_stack_size) {
            //std::cout << "Node Found!\n";
            // Debug: Log the match for clarity
            /*
            std::cout << "Node Found: "
                      << "name = " << name
                      << ", branch_type = " << branch_type
                      << ", branch_id = " << branch_id
                      << ", call_stack_size = " << call_stack_size << "\n";
            */
            return currentNode; // Found the node
        }

        // Add all children of the current node to the queue for further exploration
        for (TreeNode* child : currentNode->childrenPtrs) {
            if (child) nodesToExplore.push(child);
        }
    }
    //std::cout << "Node not Found!\n";
    // Debug: Log that the node was not found
    /*
    std::cout << "Node not found: "
              << "name = " << name
              << ", branch_type = " << branch_type
              << ", branch_id = " << branch_id
              << ", call_stack_size = " << call_stack_size << "\n";
    */
    return nullptr; // Node with specified name and branch_id not found
}

/*
//version 0
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return false; // An empty subtree is considered to satisfy the condition.
    }

    return false;
}
*/

/*
// version 1: 9m34s - 886
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; // An empty subtree is considered to satisfy the condition.
    }

    // Check the current node's conditions.
    //if (node->taken != 1) {
    if (node->taken != 1 || node->visit_cnt < 2) {
        return false;
    }

    // Recursively check all child nodes.
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) { // Explicitly specify the template parameter T
            return false;
        }
    }

    return true;
}
*/

/*
// version 2: 9m17s - 886
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; // An empty subtree is considered to satisfy the condition.
    }

    // Check the current node's conditions.
    if (node->taken == 0 || node->visit_cnt < 2) {
        return false;
    }

    // Check the first child's conditions, if a child exists.
    if (!node->childrenPtrs.empty()) {
        const auto* firstChild = node->childrenPtrs.front();
        //if (firstChild == nullptr)
        //    return false;
        if (firstChild && 
            (firstChild->taken == 0 || firstChild->visit_cnt < 2)) {
            return false;
        }
    } 

    // Recursively check all child nodes.
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) { // Explicitly specify the template parameter T
            return false;
        }
    }

    return true;
}
*/


/*
// version 3: 42m16s - 829 (too long)
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; 
        // Interpreted as: “An empty subtree trivially satisfies all conditions.”
    }

    // 1) Check the current node's conditions.
    if (node->taken == 0 || node->visit_cnt < 2) {
        return false;
    }

    // 2) NEW CHECK: If the node does NOT have any children, return false.
    //    (This is the most likely reading of “if the given node have no child, return false.”)
    if (node->childrenPtrs.empty()) {
        return false;
    }

    // 3) Check the first child's conditions, if a child exists.
    //    (At this point, we know childrenPtrs is not empty.)
    {
        const auto* firstChild = node->childrenPtrs.front();
        if (firstChild && (firstChild->taken == 0 || firstChild->visit_cnt < 2)) {
            return false;
        }
    } 

    // 4) Recursively check all child nodes.
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) {
            return false;
        }
    }

    return true;
}
*/


// version 4: 69m31s - 906 (too long)
/*
#include<random>
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
  if (!node) {
      return true; 
     // Interpreted as: “An empty subtree trivially satisfies all conditions.”
  }
  srand(time(NULL));
  if (rand() % 2) {
    return false;
  } else {
    return true;
  }
}
*/


/*
// version 5: 20m11s - 887
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; // An empty subtree is considered to satisfy the condition.
    }

    // Check the current node's conditions.
    //if (node->taken != 1) {
    if (node->taken != 1 || node->visit_cnt < 3) {
        return false;
    }

    // Recursively check all child nodes.
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) { // Explicitly specify the template parameter T
            return false;
        }
    }

    return true;
}
*/

/*
// version 6: 9m10s - 886
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; 
    }

    // Check the current node's conditions.
    if (node->taken == 0 || node->visit_cnt < 2) {
        return false;
    }

    // Check the first child's conditions, if a child exists.
    if (!node->childrenPtrs.empty()) {
        const auto* firstChild = node->childrenPtrs.front();
        //if (firstChild == nullptr)
        //    return false;
        if (firstChild && 
            (firstChild->taken == 0 || firstChild->visit_cnt < 3)) {
            return false;
        }
    } 

    // Recursively check all child nodes.
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) { // Explicitly specify the template parameter T
            return false;
        }
    }

    return true;
}
*/

template <typename T>
int calculateNodeDepth(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return -1; // Return -1 if the node is nullptr, indicating an invalid input.
    }

    int depth = 0;
    const typename GenericTree<T>::TreeNode* current = node;

    // Traverse up the tree using the parent pointers until reaching the root
    while (current->parentPtr) {
        depth++;
        current = current->parentPtr;
    }

    return depth;
}



// Traverse the tree and calculate weights for each node
template <typename T>
void calculateWeights(const typename GenericTree<T>::TreeNode* node, std::vector<double>& weights) {
    if (!node) return;

    // Calculate weight for the current node
    double weight = (1.0 - node->taken) + (1.0 / (node->visit_cnt + 1)); // Example weight formula
    weights.push_back(weight);

    // Recur for all children
    for (const auto* child : node->childrenPtrs) {
        calculateWeights<T>(child, weights);
    }
}


// looks good
/*
template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node) {
    if (!node) {
        return true; // An empty subtree is considered to satisfy the condition.
    }

    double base_threshold = 1.0;
    // Get the depth of the current node
    int depth = 0;
    const typename GenericTree<T>::TreeNode* current = node;
    while (current->parentPtr) {
        depth++;
        current = current->parentPtr;
    }

    // Calculate the weight for the current node
    double alpha = 3.0;  // Weight for untaken nodes
    double beta = 5.0;   // Weight for rarely visited nodes
    double gamma = 0.01;  // Depth penalty

    double node_weight = alpha * (1.0 - node->taken) + beta * (1.0 / (node->visit_cnt + 1)) - gamma * depth;

    // Calculate a dynamic threshold
    double threshold = base_threshold;

    // Decide whether to solve constraints based on weight
    if (node_weight >= threshold) {
        // Explore this node and solve constraints
        return false; // Mark it as needing exploration
    }

    // Recursively check all children
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child)) {
            return false;
        }
    }

    return true; // All nodes satisfy conditions or don't need further exploration
}
*/

template <typename T>
bool areAllNodesTakenAndVisited(const typename GenericTree<T>::TreeNode* node, double a, double b, double c, double t) {
    if (!node) {
        return true; // An empty subtree is considered to satisfy the condition.
    }

    // Calculate the depth of the current node
    int depth = 0;
    const typename GenericTree<T>::TreeNode* current = node;
    while (current->parentPtr) {
        depth++;
        current = current->parentPtr;
    }

    // Parameters for weight calculation
    const double alpha = a;              // Priority for untaken branches
    const double beta =  b;               // Priority for rarely visited nodes
    const double gamma = c;              // Reward for depth
    //const double random_scale = 0.3;       // Scale for random factor

    //const double alpha = getEnvD("ALPHA");              // Priority for untaken branches
    //const double beta = getEnvD("BETA");               // Priority for rarely visited nodes
    //const double gamma = getEnvD("GAMMA");              // Reward for depth
    //const double random_scale = getEnvD("RANDOM");       // Scale for random factor

    // Calculate weight for the current node
    double untaken_priority = (1.0 - node->taken);                     // Untaken branch priority
    double visit_priority = 1.0 / (node->visit_cnt + 1);               // Rare visit encouragement
    double depth_priority = gamma * depth;                             // Depth reward
    //double random_factor = static_cast<double>(rand()) / RAND_MAX;     // Random factor
    int MAX_VISITS = 10;
    double node_weight = 0;
    if (node->visit_cnt > MAX_VISITS) {
      // Mark node as low-priority or skip entirely
      node_weight = 0.0;
    } else {
      // Normal weight calculation
      node_weight = alpha * untaken_priority +
                  beta * visit_priority + depth_priority;
    }

    // Threshold to decide whether to explore this node
    const double base_threshold = t; // Adjust as needed
    if (node_weight >= base_threshold) {
        // Node needs further exploration
        return false;
    }

    // Recursively check all children
    for (const auto* child : node->childrenPtrs) {
        if (!areAllNodesTakenAndVisited<T>(child, a, b, c, t)) {
            return false;
        }
    }

    return true; // All nodes are sufficiently explored
}